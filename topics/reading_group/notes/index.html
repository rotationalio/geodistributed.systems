<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><meta name=description content="Details, notes, and questions from the Summer 2021 Reading Group."><link rel=icon href=/images/favicon.png type=image/png><title>Discussion Notes :: Geo-Distributed Systems</title><link href=/css/nucleus.css?1632961070 rel=stylesheet><link href=/css/fontawesome-all.min.css?1632961070 rel=stylesheet><link href=/css/hybrid.css?1632961070 rel=stylesheet><link href=/css/featherlight.min.css?1632961070 rel=stylesheet><link href=/css/perfect-scrollbar.min.css?1632961070 rel=stylesheet><link href=/css/auto-complete.css?1632961070 rel=stylesheet><link href=/css/atom-one-dark-reasonable.css?1632961070 rel=stylesheet><link href=/css/theme.css?1632961070 rel=stylesheet><link href=/css/hugo-theme.css?1632961070 rel=stylesheet><link href=/css/theme-blue.css?1632961070 rel=stylesheet><script src=/js/jquery-3.3.1.min.js?1632961070></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style></head><body data-url=/topics/reading_group/notes/><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=/><svg id="grav-logo" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" height="100%" viewBox="0 0 64 80" style="enable-background:new 0 0 32 32" alt="Created by Eucalyp from the Noun Project" title="Created by Eucalyp from the Noun Project"><g><path d="M41.154 46.328l1.079 1.684c.59-.378 1.166-.793 1.711-1.234l-1.259-1.555C42.197 45.618 41.682 45.989 41.154 46.328z"/><path d="M37.774 47.995l.68 1.881c.66-.238 1.313-.517 1.942-.827l-.886-1.793C38.948 47.533 38.364 47.782 37.774 47.995z"/><path d="M24.445 16.767l-.89-1.791c-.709.352-1.403.753-2.062 1.192l1.107 1.665C23.19 17.44 23.811 17.082 24.445 16.767z"/><path d="M15.421 28.221c.868-3.826 3.066-7.264 6.19-9.679l-1.224-1.582c-3.49 2.699-5.947 6.541-6.917 10.819L15.421 28.221z"/><path d="M63 32c0-2.582-3.089-4.807-8.928-6.454C51.274 15.997 42.442 9 32 9S12.725 15.997 9.928 25.546C4.089 27.193 1 29.419 1 32c0 2.763 3.572 4.924 8.923 6.436C12.714 47.995 21.552 55 32 55c6.742.0 13.066-2.923 17.448-8.028C49.631 46.986 49.814 47 50 47c3.86.0 7-3.141 7-7 0-.825-.151-1.613-.414-2.349C60.841 36.101 63 34.203 63 32zM32 11c4.587.0 8.821 1.495 12.279 4H41v2h5.669C50.569 20.815 53 26.126 53 32c0 .551-.024 1.103-.067 1.653C52.04 33.238 51.048 33 50 33H35c-1.103.0-2-.897-2-2s.897-2 2-2h4c2.206.0 4-1.794 4-4s-1.794-4-4-4H29c-1.103.0-2-.897-2-2s.897-2 2-2h6v-2h-6c-2.206.0-4 1.794-4 4s1.794 4 4 4h10c1.103.0 2 .897 2 2s-.897 2-2 2h-4c-2.206.0-4 1.794-4 4s1.794 4 4 4h10.111c-.937.916-1.614 2.093-1.922 3.411C39.635 38.797 35.881 39 32 39c-4.478.0-8.525-.253-12.079-.679C20.233 38.12 20.602 38 21 38h2c2.206.0 4-1.794 4-4 0-2.206-1.794-4-4-4H11.101C12.112 19.356 21.096 11 32 11zM11 32h12c1.103.0 2 .897 2 2s-.897 2-2 2h-2c-1.474.0-2.75.81-3.444 2.001-2.227-.335-4.227-.739-5.978-1.189C11.213 35.264 11 33.658 11 32zM3 32c0-1.106 1.722-2.739 6.393-4.209C9.139 29.157 9 30.562 9 32c0 1.43.138 2.828.389 4.186C5.26 34.877 3 33.321 3 32zm9.234 7.023c1.5.344 3.1.644 4.774.9C17.007 39.949 17 39.974 17 40c0 2.206 1.794 4 4 4h10c1.103.0 2 .897 2 2s-.897 2-2 2H18.431c-2.792-2.371-4.944-5.46-6.197-8.977zM32 53c-3.936.0-7.609-1.108-10.761-3H31c2.206.0 4-1.794 4-4s-1.794-4-4-4H21c-1.033.0-1.876-.791-1.979-1.797C23.148 40.729 27.613 41 32 41c3.815.0 7.51-.195 11.022-.562.168 2.693 1.857 4.979 4.224 5.996C43.284 50.621 37.812 53 32 53zm18-8c-2.757.0-5-2.243-5-5s2.243-5 5-5 5 2.243 5 5-2.243 5-5 5zm5.632-9.14c-.249-.338-.526-.652-.83-.94C54.924 33.954 55 32.977 55 32c0-1.438-.139-2.843-.393-4.209C59.277 29.26 61 30.892 61 32c0 1.246-2.002 2.667-5.368 3.86z"/><path d="M50 51h3.901C48.386 57.377 40.517 61 32 61c-9.207.0-17.663-4.228-23.201-11.598L7.2 50.604C13.119 58.481 22.158 63 32 63c8.896.0 17.128-3.702 23-10.229V56h2v-7h-7v2z"/><path d="M14 13h-3.902C15.614 6.623 23.483 3 32 3c9.208.0 17.665 4.228 23.202 11.601l1.6-1.201C50.883 5.52 41.843 1 32 1 23.104 1 14.873 4.702 9 11.229V8H7v7h7V13z"/><rect x="37" y="15" width="2" height="2"/><rect x="41" y="29" width="2" height="2"/><rect x="49" y="29" width="2" height="2"/><rect x="45" y="29" width="2" height="2"/></g></svg></a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script type=text/javascript src=/js/lunr.min.js?1632961070></script><script type=text/javascript src=/js/auto-complete.js?1632961070></script><script type=text/javascript>var baseurl="https://geodistributed.systems/"</script><script type=text/javascript src=/js/search.js?1632961070></script></div><section id=homelinks><ul><li><a class=padding href=/><i class="fas fa-home"></i> Home</a></li></ul></section><div class=highlightable><ul class=topics><li data-nav-id=/topics/ title="Topics in Distributed Systems" class="dd-item
parent"><a href=/topics/>Topics in Distributed Systems</a><ul><li data-nav-id=/topics/reading_group/ title="Summer 2021 Reading Group" class="dd-item
parent"><a href=/topics/reading_group/>Summer 2021 Reading Group</a><ul><li data-nav-id=/topics/reading_group/notes/ title="Discussion Notes" class="dd-item active"><a href=/topics/reading_group/notes/>Discussion Notes</a></li><li data-nav-id=/topics/reading_group/community/ title=Community class=dd-item><a href=/topics/reading_group/community/>Community</a></li></ul></li></ul></li><li data-nav-id=/oss/ title="Open Source" class=dd-item><a href=/oss/>Open Source</a><ul><li data-nav-id=/oss/honu/ title=Honu class=dd-item><a href=/oss/honu/>Honu</a></li><li data-nav-id=/oss/concur/ title=Concur class=dd-item><a href=/oss/concur/>Concur</a></li></ul></li><li data-nav-id=/talks/ title="Posters and Talks" class=dd-item><a href=/talks/>Posters and Talks</a></li></ul><section id=prefooter><hr><ul><li><a class=padding><i class="fas fa-language fa-fw"></i><div class=select-style><select id=select-language onchange="location=this.value"><option id=en value=https://geodistributed.systems/topics/reading_group/notes/ selected>English</option></select><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="255" height="255" viewBox="0 0 255 255" style="enable-background:new 0 0 255 255"><g><g id="arrow-drop-down"><polygon points="0,63.75 127.5,191.25 255,63.75"/></g></g></svg></div></a></li></ul></section><section id=footer><center><a class=github-button href=https://github.com/rotationalio/geodistributed.systems/archive/master.zip data-icon=octicon-cloud-download aria-label="Download matcornic/hugo-theme-learn on GitHub">Download</a>
<a class=github-button href=https://github.com/rotationalio/geodistributed.systems data-icon=octicon-star data-show-count=true aria-label="Star matcornic/hugo-theme-learn on GitHub">Star</a>
<a class=github-button href=https://github.com/rotationalio/geodistributed.systems/fork data-icon=octicon-repo-forked data-show-count=true aria-label="Fork matcornic/hugo-theme-learn on GitHub">Fork</a><p>Built with <a href=https://github.com/rotational.io/geodistributed.systems><i class="fas fa-heart"></i></a> from <a href=https://rotational.io>Rotational Labs</a> and <a href=https://gohugo.io/>Hugo</a></p></center><script async defer src=https://buttons.github.io/buttons.js></script><script src=https://d3js.org/d3.v7.min.js></script></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span>
<span id=toc-menu><i class="fas fa-list-alt"></i></span>
<span class=links>Discussion Notes</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#session-1-the-promise-and-the-peril-of-really-big-models>Session 1: The Promise and the Peril of Really Big Models</a></li><li><a href=#session-2-what-archeology-can-teach-us-about-distributed-systems>Session 2: What Archeology Can Teach Us about Distributed Systems</a></li><li><a href=#session-3-fantastic-failures-and-where-to-find-them>Session 3: Fantastic Failures and Where to Find Them</a></li><li><a href=#session-4-what-is-time-in-a-distributed-system>Session 4: What is &ldquo;Time&rdquo; in a Distributed System?</a></li><li><a href=#session-5-can-distributed-systems-learn>Session 5: Can Distributed Systems Learn?</a></li><li><a href=#session-6-languages-of-distributed-systems>Session 6: Languages of Distributed Systems</a></li><li><a href=#session-7-takeaways-from-hotstorage-2021>Session 7: Takeaways from HotStorage 2021</a></li><li><a href=#session-8-what-is-a-file-anyway>Session 8: What is a &ldquo;File&rdquo; Anyway?</a></li><li><a href=#session-9-computing-on-distributed-data>Session 9: Computing on Distributed Data</a></li><li><a href=#session-10-the-importance-of-understandability>Session 10: The Importance of Understandability</a></li><li><a href=#farewell-and-onto-new-things>Farewell and Onto New Things&mldr;</a></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Discussion Notes</h1><h2 id=session-1-the-promise-and-the-peril-of-really-big-models>Session 1: The Promise and the Peril of Really Big Models</h2><p><strong>Date</strong>:
June 16 8:30PM EDT/June 17 8:30AM HKT</p><p><strong>Reading</strong>:
Bender, et al. (2021) <a href=https://dl.acm.org/doi/pdf/10.1145/3442188.3445922>On the Dangers of Stochastic Parrots: Can Language Models Be Too Big?</a></p><p><strong>Questions and Discussion Points:</strong></p><p>Model Architectures</p><ul><li>How do 1-shot and 0-shot learning work?</li><li>How important is attention in model training?</li><li>How do multilingual models work?</li><li>What are some good approaches for multiple machine learning models working together?</li></ul><p>&ldquo;Good Models&rdquo;</p><ul><li>What are some different ways of scoring machine learning models?</li><li>Is there a way to make toxicity scoring work better?</li><li>When is a machine learning model too small? Is there such a thing?</li></ul><p>Data Sourcing</p><ul><li>What are the economies of training data?</li><li>If not the internet, where is a better place to get data?</li></ul><p>Energy Efficiency</p><ul><li>How can machine learning be made more energy efficient?</li><li>Is there a more efficient way to do consensus (e.g. emergent consensus)?</li></ul><p>Distributed Systems</p><ul><li>What is a distributed system?</li><li>What are the foundations of distributed systems?</li><li>What are the roots of consensus algorithms?</li><li>How is reinforcement learning used in distributed systems?</li><li>What is an &ldquo;intelligent distributed system&rdquo;?</li></ul><h2 id=session-2-what-archeology-can-teach-us-about-distributed-systems>Session 2: What Archeology Can Teach Us about Distributed Systems</h2><p><strong>Date</strong>:
June 23 8:30PM EDT/June 24 8:30AM HKT</p><p><strong>Reading</strong>:
Lamport, Leslie. &ldquo;The part-time parliament.&rdquo; Concurrency: the Works of Leslie Lamport. 2019. 277-317.</p><p><strong>Questions and Discussion Points:</strong></p><p>The Consensus Metaphor</p><ul><li>To what extent did Lamport mean to tell the Paxos story in earnest versus an extended allegory?</li><li>How well has the consensus metaphor served the distributed systems community?</li><li>What is concurrency and what does it look like in the context of the part time parliament metaphor?</li></ul><p>Consistency of the Distributed Log</p><ul><li>Consistency is about synchronization, which repairs entropy.</li><li>What are the different types of consistency and which is illustrated by Lamport&rsquo;s part time parliament?</li><li>What is the difference between eventual consistency and monotonic reads?</li><li>What is the difference between a &ldquo;log&rdquo; and the idea of a distributed ledger? Are these the same?</li></ul><p>Paxos & Optimizations</p><ul><li>Do any real world applications use Paxos?</li><li>2 rounds of communication are required for Paxos, this can be optimized using leader optimization (remove the Prepare phase), ballot optimization, or through optimistic consensus (e.g. Fast Path, ePaxos).</li></ul><h2 id=session-3-fantastic-failures-and-where-to-find-them>Session 3: Fantastic Failures and Where to Find Them</h2><p><strong>Date</strong>:
June 30 8:30PM EDT/July 1 8:30AM HKT</p><p><strong>Reading</strong>:</p><p>Muralidhar, et al. (2014) <a href=https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-muralidhar.pdf>f4: Facebook’s Warm BLOB Storage System</a></p><p><strong>Questions and Discussion Points:</strong></p><p>Optimization vs. Flexibility</p><ul><li>Is optimization (e.g. using data age, application-level requirements) enough to make a distributed system &ldquo;intelligent&rdquo;?</li><li>Where do heuristics about data placement start to break down? For instance, do the rules that work for a big content creator with millions of followers also apply to everyday social media users?</li><li>What features could you use in a distributed system to train a model that would nominate data to be moved from hot to warm or cold storage?</li><li>Could you build a distributed system that would be able to adapt to new blob types, e.g. know how to store them most efficiently?</li></ul><p>The UX of Failure</p><ul><li>As users we often experience failures from eventual consistency:<ul><li>Buying plane tickets - when is the purchase final? How do we know?</li><li>Food ordering apps - the fries gets cold while we&rsquo;re waiting for the system to get consistent.</li><li>We thought we won the game, but a few seconds later, we&rsquo;re told it was another player.</li></ul></li><li>We also experience failures in data systems that are in transition:<ul><li>Systems that experience massive (e.g. seasonal) spikes in usage that break consistency.</li><li>Systems that are being changed to adapt to new market conditions (e.g. conflict between point of sales systems and e-commerce systems).</li></ul></li><li>We have also experienced correlated failures, such as all of our drives failing simultaneously.</li></ul><p>Planning for Failure</p><ul><li>What is the robustness model when failure happens? What&rsquo;s the &ldquo;intelligent&rdquo; approach to recover from failure?</li><li>How does data encryption work in a distributed system with correlated failures? What&rsquo;s the relationship between fault tolerance and encryption?</li></ul><p><strong>Related Papers</strong>:</p><p>Lu, et al. (2015) <a href=https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/240-lu.pdf>Existential Consensus: Measuring and Understanding Consistency at Facebook</a></p><p>Santry, et al. (2004) <a href=http://www.cs.fsu.edu/~awang/courses/cop5611_s2004/elephant.pdf>Elephant: The File System that Never Forgets</a></p><h2 id=session-4-what-is-time-in-a-distributed-system>Session 4: What is &ldquo;Time&rdquo; in a Distributed System?</h2><p><strong>Date</strong>:
July 7 8:30PM EDT/July 8 8:30AM HKT</p><p><strong>Reading (select one of these)</strong>:</p><p>Lamport (1978) <a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf>Time, Clocks, and the Ordering of Events in a Distributed System</a></p><p>Corbett, et al (2012) <a href=https://research.google/pubs/pub39966>Spanner: Google&rsquo;s Globally-Distributed Database</a></p><p><strong>Questions and Discussion Points:</strong></p><p>&ldquo;Happened Before&rdquo;</p><ul><li>In the Lamport paper, the &ldquo;happened before&rdquo; relation evolves from a simple relationship between events in the same process (&ndash;>) to a relationship between processes happening across a system of clocks (==>) and finally to an even stronger relation that describes distributed processes within and outside the system (<strong>&ndash;></strong>).</li><li>The system of clocks relies on two things to synchronize; first, a mechanism to coordinate via monotonic counters, and a method for arbitrarily ordering system processes (e.g. a global unique identifier for system processes).</li><li>Colloquially we are used to thinking of the word &ldquo;concurrent&rdquo; to mean something like &ldquo;simultaneous&rdquo;. However, Lamport introduces a novel way of thinking about concurrency with respect to the &ldquo;happened before&rdquo; relation; namely that two distinct events <code>a</code> and <code>b</code> are concurrent if <code>a</code> did not happen before <code>b</code> and <code>b</code> did not happen before <code>a</code>. From the system&rsquo;s perspective, these two events may as well have happened simultaneously, since we don&rsquo;t have a way to order them.</li><li>How well does the system of clocks scale as system size increases?</li></ul><p>Synchronization for the Rich and Famous</p><ul><li>Google&rsquo;s globally distributed system Spanner demonstrates an evolution from the Lamport clock for the age of big data.</li><li>Spanner leverages TrueTime, an API that represents time as an interval and which accounts for variations across geographically remote components of a system. TrueTime is not source available, but there are some details about how it works in this paper and in follow on publications.</li><li>Spanner depends on expensive hardware, including both atomic clocks and GPS devices, apparently collocated with every single rack in the system.</li><li>Spanner is commercially available but does not seem to have much marketing behind it. It is very expensive. Could it be made cheaper by increasing the size of the TrueTime window?</li><li>How well does Spanner work as the system nodes get further apart geographically? Although the phrase &ldquo;global&rdquo; comes up a lot in the paper, the examples seem mostly to detail coordination across regions in North America.</li></ul><p>To Tick or Not to Tick</p><ul><li>Lamport&rsquo;s paper ends with a proof that physical clocks exist — meaning clocks that are totally differentiable, with no intervals and no ticks. This was likely Lamport&rsquo;s goal, since at the time he was working to try to devise a computer-based clock for SRI.</li><li>However, 34 years later, the Spanner paper seems to call the existence of physical clocks into question. If Google can&rsquo;t do it without intervals and fancy hardware, can it be done?</li></ul><p><strong>Related Resources</strong>:</p><p>SE-Radio (2019) <a href=https://www.se-radio.net/2019/08/episode-377-heidi-howard-on-distributed-consensus/>Episode 377: Heidi Howard on Distributed Consensus</a></p><p>Kleppman (2020) <a href="https://www.youtube.com/watch?v=oeycOVX70aE&list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB&index=25">Distributed Systems 8.2: Google&rsquo;s Spanner</a></p><h2 id=session-5-can-distributed-systems-learn>Session 5: Can Distributed Systems Learn?</h2><p><strong>Date</strong>:
July 14 8:30PM EDT/July 15 8:30AM HKT</p><p><strong>Reading</strong>:</p><p>Bengfort, et al. (2019) <a href="https://kelehers.me/papers/get.pl?tag=icdcs018">Anti-Entropy Bandits for Geo-Replicated Consistency</a></p><p><strong>Questions and Discussion Points:</strong></p><p>Punishment and Reward</p><ul><li>The authors apply reinforcement learning (RL) to optimize anti-entropy in a distributed system.</li><li>Coming up with a good reward function is a common blocker to implementing RL. The clarity of the reward function (rewards for fast, productive sessions) is interesting; this is a great application for RL.</li></ul><p>Lessons Learned</p><ul><li>There are a few human-detectable patterns from the RL, such as data center co-location. The model has learned that physical distance is a good measure to improve anti-entropy, but it&rsquo;s not a perfect correlation. </li><li>It&rsquo;s difficult to tell the differences in performance between the nodes.</li><li>Another result is that not all data centers are created equal, which you can see in the data, especially when they are in the same geographic area e.g. Montreal performs far worse then VA or Ohio in terms of moving data across the network.</li><li>One notable absence is that we didn&rsquo;t see a hierarchy emerge; we expected to see super-spreaders in different regions, but that wasn&rsquo;t prevalent.</li><li>It seems like there would be a great deal of overlap with routing? There are some very interesting routing algorithms (e.g. traveling salesman) though there are different requirements. One significant difference is that routing is local only vs. the global system the authors experimented on.</li></ul><p>Experimental Design</p><ul><li>The authors selected all regions that were available at the time (ex Beijing) with the caveat that some of these regions have many availability zones and they selected A, B, and C.</li><li>The accesses were balanced and consistent, which made for good experimental conditions, but are admittedly not representative of the dynamism of throughput in real applications.</li><li>It was useful to do a thought experiment and think of the system as a phone tree that disseminates downward, which is similar to the super-spreader analogy. The authors controlled for many variables; in the real world, you would most likely see more variability and a heterogeneous topology. If your network optimized for cost, would you show the cheapest nodes vs speed vs compute? Or you could optimize the network for speed or compute.</li><li>With reinforcement learning in general, one issue is: What happens when the world changes? When a system is dynamic? There is some research on this but it often comes down to hard resets; it&rsquo;s often 100-150 time steps to learn the new system, which is not very long, but it doesn&rsquo;t allow for much flexibility.</li></ul><p>Achieving Fairness</p><ul><li>One interesting concept is &ldquo;stomping&rdquo; i.e. when there are concurrent writes, which gets stomped out? Is there any discussion in the community about equitable stomping? Does it depend on a region that is faster, or more storage? Is there any discussion about how to make it as random as possible beyond Precedence IDs?</li><li>Precedence IDs are human assigned by sys admins and it&rsquo;s an opportunity to inject human bias into the system; e.g. VA > CA > OH etc.; in the system Rotational just deployed, we assigned Precedence IDs using a round-robin method.</li><li>This raises an interesting question: What other ways can human bias be injected into a system that we may not understand or be conscious of?</li><li>In some ways, it&rsquo;s reasonable to assume any intelligent system will have some human bias injected e.g. a system could learn bias based on user engagement (heavy user); we may not be able to remove bias but can we find ways to combat or adapt the system for a bias?</li><li>Randomization may be one way to combat bias; it&rsquo;s an open question if bias is worth thinking about it as long as the system has been consciously set up to combat it.</li><li>Another thought experiment: Imagine a linear network that propagates. There&rsquo;s no way to know how far a write has propagated; so the world could read a write that has a lower precedence but it&rsquo;s the last to know; however, consensus does not allow that to happen; it totally order the writes.</li></ul><p>Future Research</p><ul><li>Can you optimize for cost? For example, in Google Cloud, you incur a cost between continents; you really only want one node and not all nodes in the transfers; on the other side of the coin, you want bandwidth; knowing that you&rsquo;ll always have a transfer vector, you can ask questions such as: Can you minimize the transfer cost? Are there intersectional differences inside the cloud? </li><li>The other thing to think about is user experience. Might we include inconsistencies in the reward function?</li><li>Another possible optimization is objects edited together vs objects edited separately? Can we increase their reciprocal transparency visibility based on this variable? </li><li>What would happen if we injected chaos; how does that impact the system?</li><li>How could this network be more responsive, more flexible? What happens when accesses change over time? </li></ul><h2 id=session-6-languages-of-distributed-systems>Session 6: Languages of Distributed Systems</h2><p><strong>Date</strong>:
July 21 8:30PM EDT/July 22 8:30AM HKT</p><p><strong>Reading</strong>:
gRPC Authors (2021) <a href=https://grpc.io/docs/what-is-grpc/>What is gRPC?</a></p><p><strong>Questions and Discussion Points:</strong></p><p>HTTP vs HTTP2: A Major Upgrade</p><ul><li>Much of gRPC&rsquo;s functionality is enabled by HTTP2</li><li>One of the biggest benefits of HTTP2 is it allows for full duplex communication; the web browser can make one request and get all of the data at once (server to client + client to server)</li><li>A lot of things got jammed into HTTP that it wasn&rsquo;t necessarily designed for e.g. web sockets, long-term connections, etc.</li><li>HTTP2 is a binary format vs plaintext in HTTP; a lot of the issues in HTTP are due to plaintext encoding</li><li>Because of its binary format, HTTP2 adds security and massively improves performance e.g. variable inline encoding, compression, better performance management overall, etc.</li><li>HTTP is like the Model T in that Ford didn&rsquo;t know we would build interstate highways; HTTP2 is focused on what the internet will look like in 30 years and now the question is when we&rsquo;ll see it in browsers</li></ul><p>API Design</p><ul><li>RESTful APIs are designed to be human-readable whereas gRPC is generally for microservices communication since it is much faster, takes up much less memory, etc.</li><li>One design consideration is human-to-machine communication vs. machine-to-machine or service-to-service communication</li><li>gRPC is a strong contract about how to talk to each other between the data provider and data consumer; it&rsquo;s a very firm and specific but it opens up flexibility for a wide range of business use cases</li><li>gRPC is used widely in microservices e.g. shopping cart management services that talk to inventory management services, etc.</li><li>gRPC allows for pre-processing or &ldquo;pre-code&rdquo; to be run before services can talk to each other, which means strict communication protocols e.g. the service has to conform and meet certain requirements before it can talk to another service</li><li>gRPC is useful for advanced services such as moving around large amounts of data between services</li><li>Restful APIs are suited for external programs since they allow for flexibility whereas gRPCs could be better for internal services because they can tightly control design architecture e.g. Google as an example. gRPC is more efficient for asynchronous communication vs REST which is better for sequential communication</li><li>Generally, gRPCs are well-suited for intelligent distributed systems because of its dependence on HTTP2 and its point-to-point communication (that is initiated by one point, not either)</li><li>There are other lower-level libraries like ZeroMQ that could be useful for distributed systems</li></ul><p>Protocol Buffers in The Wild</p><ul><li>Probably many of us have used protobufs because that&rsquo;s how Tensorflow works e.g. passing messages between the neural network layers</li><li>Tensorflow has several protobuf and gRPC dependencies; for example, TensorFlow Serving, where models are hosted, is gRPC</li></ul><p>Programming Languages & Distributed Systems</p><ul><li>Languages that get closer to the core of how the computer/machine communicates seem to be better for distributed systems</li><li>In contrast, a language like Python is designed to be more human-readable and is less suitable for distributed systems</li><li>While protocol buffers are meant to be language agnostic, gRPC is especially popular with C++ and Golang developers, which makes sense when you think about the built-in coroutines (or Go routines) and channels that are features of those languages. Similar to the reason that Python developers like JSON so much, since it can be seamlessly converted into dictionary objects.</li></ul><p><strong>Related Resources</strong></p><ul><li>Various <a href=https://zguide.zeromq.org/docs/chapter4/%5Dhttps://zguide.zeromq.org/docs/chapter4/>networking pirate patterns in ZMQ</a></li><li>Podcast interview of <a href=https://www.se-radio.net/2020/08/episode-421-doug-fawley-on-grpc/>gRPC tech lead Doug Fawley at Google</a></li></ul><h2 id=session-7-takeaways-from-hotstorage-2021>Session 7: Takeaways from HotStorage 2021</h2><p><strong>Date</strong>:
July 28 8:30PM EDT/July 29 8:30AM HKT</p><p><strong>Reading</strong>:
This week, instead of a shared reading, please register and attend some portion of <a href=https://www.hotstorage.org/2021/>HotStorage 2021</a>, so that we can discuss highlights and takeaways during our usual meeting time.</p><p><strong>Questions and Discussion Points:</strong></p><p>Key Papers</p><ul><li><a href=https://dl.acm.org/doi/10.1145/3465332.3470882>Matte et al (2021) &ldquo;Scalable but Wasteful: Current State of Replication in the Cloud&rdquo;</a></li><li><a href=https://www.hotstorage.org/2021/2021-slides/ndp_for_obj_stores_slids_adams.pdf>Adams et al (2021) &ldquo;Enabling Near-Data Processing in Distributed Object Storage Systems&rdquo;</a></li><li><a href=https://dl.acm.org/doi/10.1145/3465332.3470876>Deshpande et al (2021) &ldquo;Self-service Data Protection for Stateful Containers&rdquo;</a></li><li><a href=https://www.hotstorage.org/2021/2021-slides/SentiLog-SLIDES-Zhang.pdf>Zhang & Dai (2021) &ldquo;SentiLog: Anomaly Detecting on Parallel File Systems via Log-based Sentiment Analysis&rdquo;</a></li><li><a href=https://www.hotstorage.org/2021/2021-slides/KML-ML-Framework-Storage-OSs-SLIDES-Ibrahim_Umit_Akgun.pdf>Akgun et al (2021) &ldquo;A Machine Learning Framework to Improve Storage System Performance&rdquo;</a></li></ul><p>Terms of Interest</p><ul><li>&ldquo;NDP&rdquo; - near data processing; a big focus of the conference. Managing hundreds of storage nodes, making the data more distributed</li><li>&ldquo;CRDTs&rdquo; - conflict-free replicated datatype</li><li>&ldquo;LSM tree&rdquo; - log-structured merge tree</li><li>&ldquo;SSD&rdquo; - solid state drive</li><li>&ldquo;RPO&rdquo; - recovery point objective</li><li>Blocks vs Rocks - Blocks are uniformly sized vs. rocks, which are more flexible and variable-sized and supports more granularity and more/ different types of file sizes; PebbleDB is smaller rocks</li><li>Shards vs Slices vs Stripes</li><li>&ldquo;rowhammering&rdquo;</li><li>PFS: why no global IDs?</li><li>Two-phase backup scheduler</li></ul><p>Types of Consistency</p><ul><li>We mostly have been talking about eventual consistency so far. Consistency is about what users can expect from a system.</li><li>As you move up the spectrum toward strong consistency, the more coordination is needed i.e there is a lot of message traffic, which often leads to degraded performance, which runs into the CAP problem.</li><li>There is a spectrum from weak to strong consistency:<ul><li>&ldquo;weak consistency&rdquo;: No guarantee that systems will converge</li><li>&ldquo;eventual consistency&rdquo; (and &ldquo;strong eventual consistency&rdquo;): If you stop writing, the system will eventually become consistent.</li><li>&ldquo;causal consistency&rdquo;: guarantees all processes observe causally-related operations in a common order.</li><li>&ldquo;sequential consistency&rdquo;: Ordered operations that are observable e.g. the Lamport paper</li><li>&ldquo;strong consistency&rdquo; (aka linearizability): For every person on earth there is a single order of operations. Spanner is probably the closest example we&rsquo;ve looked at so far.</li></ul></li></ul><p>New Technologies</p><ul><li><p>Databases, File Systems, and Object Storage</p><ul><li>CockroachDB</li><li>YugaByte</li><li>RocksDB</li><li>PebbleDB</li><li>ElmerFS</li><li>Lustre and BeeGFS (Parallel file systems)</li><li>Minio</li><li>Ceph</li><li>Storj.io</li><li>etcd</li></ul></li><li><p>Consensus Algorithms</p><ul><li>Raft</li><li>Multi-Paxos</li><li>EPaxos</li><li>Pig Paxos</li></ul></li><li><p>Libraries</p><ul><li>DeepLog</li></ul></li></ul><p>General Questions</p><ul><li><p><em>Why is it called &ldquo;Hot Storage&rdquo;?</em></p><ul><li>Originally called &ldquo;Hot Topics in Storage Systems&rdquo;; follows from a series of &ldquo;Hot&rdquo; topics in computer science such as security, networking, etc.</li><li>The name Hot Storage is also connected to electrical engineering and it&rsquo;s relation to storage systems i.e. thousands of spinning discs</li><li>Attracts a lot of interesting domains e.g. bioinformatics, DNA storage systems, ML and optimization - very interdisciplinary</li></ul></li><li><p><em>What&rsquo;s with the emphasis on flash storage?</em></p><ul><li>Might have to do with the hardware available to the participants; best way to experiment and try out new ideas and configurations.</li></ul></li><li><p><em>Is it common for there to be so many theoretical papers (compared to ones with experimental results)?</em></p><ul><li>Hot Storage has become a primary publishing venue for grad students; it gives researchers the opportunity to share/ discuss research even if they don&rsquo;t have complete results yet</li></ul></li><li><p><em>Not a lot of representation from the big cloud folks - Google, Amazon, that other one. Why is that?</em></p><ul><li>FAST is the larger conference counterpart to Hot Storage; a lot of big tech companies (Twitter, Google, FB) sponsor or attend FAST</li></ul></li></ul><h2 id=session-8-what-is-a-file-anyway>Session 8: What is a &ldquo;File&rdquo; Anyway?</h2><p><strong>Date</strong>:
August 4 8:30PM EDT/August 5 8:30AM HKT</p><p><strong>Reading</strong>:
Rosenblum & Osterhout (1991) <a href=https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf>The Design and Implementation of a Log-Structured File System</a></p><p><strong>Questions and Discussion Points:</strong></p><p>The &ldquo;Philosophy&rdquo; of Files</p><ul><li>In our every day lives, files seem mundane, but this paper raises philosophical questions about their existence that prompts a re-think. Files can be something, anything, any piece of data that you want to write to disk with some meta data. Files are made of even more basic units i.e. bits; files are an amalgamation or a collection of bits much like people are collections of molecules; the bits come together to do things and then eventually disband and go on to do other things</li><li>If you look back at many of the Hot Storage papers from last week, the knowledge and tenets of this paper are in many ways embedded in those papers</li><li>Another interesting question is the definition of &ldquo;live&rdquo; vs &ldquo;dead&rdquo; data; is &ldquo;dead&rdquo; data just deleted data? How do we define &ldquo;dead&rdquo; data? When deleting something from a file system, a lot of files systems work by removing just the meta data so it&rsquo;s somewhat easy to restore data; so truly erasing a disc means scrambling the bits so the patterns can&rsquo;t be reconstructed i.e. the pointers are gone but bits are still there. A lot has to happen to make data &ldquo;dead&rdquo; e.g. the inode that points to the chunk has to be re-written and then we have to re-write the inode map. &ldquo;dead&rdquo; data can also be any data that will be consumed by the reclamation process i.e. the process that it will reclaim chunks that no longer have an inode pointer. So there are many ways data can &ldquo;die&rdquo; e.g. when the inode is re-written, when memory is re-written</li></ul><p>The Physics of Files</p><ul><li>The block is the physical storage on the disc and each disc is a certain number of bits. Files can be decomposed into blocks (e.g. a big file might require several or many blocks). Blocks can also contain multiple files (e.g. if the files are smaller than the block size).</li><li>The file system in the paper is highly dependent on the physics of spinning disks; there is rotational latency and seek latency; the access speed was constrained by the time it takes to physically travel; it makes us appreciate the mechanics of the hardware</li><li>Today we have SSD and Flash, so seek latency is reduced but still exists; it happens in a different way; storage systems jump around to different bits e.g. NVM; there&rsquo;s still overhead so you still want to engage in as much sequential writing as you can</li><li>The log structure is still relevant even though SSD and Flash have reduced the physics of discs</li><li>It&rsquo;s interesting to note that this paper was published around the time SSD technology was under research</li></ul><p>Distributed File Systems</p><ul><li>The way that people initially solved the shared file system was using the NFS model; Dave makes a change and then information about the change goes through the network and everyone else gets to see the update, which became increasingly less performant as computers got faster and people started to create more content. Our speed expectations changed a lot!</li><li>When editing a shared file, if a file is in blocks, then ask which file is different? diff!</li><li>Git has a good diff tool; it has to track many changes from many sources; git doesn&rsquo;t think of your Python program as single thing; it looks at it in chunks and does some math and looks at what&rsquo;s different; it doesn&rsquo;t matter what has changed, but if there&rsquo;s a change, it commits the change; git uses something like a <a href=https://en.wikipedia.org/wiki/Merkle_tree>Merkle tree</a> to break things up into chunks and decide what has changed vs what has not</li></ul><p>The File System vs the Application</p><ul><li>The file system doesn&rsquo;t have much control over what happens; it controls the inode but the application has much more control over actions; write/seek/chunk/flush operations are what the file system understands but the application has a say; e.g. Vim will do things on a line-by-line basis vs emacs, which will write things in chunks</li><li>Git is different as it&rsquo;s saving multiple files from multiple sources so it has much more control</li><li>It&rsquo;s interesting to note the hardware will &ldquo;lie&rdquo; to you about what&rsquo;s really happening, especially with encryption you lose some ability; RAID will also &ldquo;lie&rdquo; as its just putting things into the buffer</li><li>A buffer is another element of a file system: it intentionally delays the writes to accumulate them and then write a chunk together; buffers may seem like an annoyance since they intentionally slow things down for sequential write efficiency</li><li>But there&rsquo;s also a danger to buffers because what happens if we buffer for too long? You could lose data and run into the security issue of a buffer overflow e.g. buffer is full, electricity goes out, and then everything unwritten is gone</li></ul><p>Building Your Own File System</p><ul><li>It&rsquo;s feasible (yet not trivial) to create your own.</li><li>Creating a file system is putting a fence around a chunk of storage on your machine and saying &ldquo;this is mine&rdquo; for the file system, and then using <a href=https://bazil.org/fuse/>Fuse</a> to write functions to manage it.</li></ul><p>Thinking About New Architectures</p><ul><li>A significant amount of work is done just moving data around; many systems today rely on technology that emerged in the 1960s</li><li>Today we have new specialized chips (ASICs), new storage options, etc</li><li>What if we built a system from the ground up to take advantage of these new technologies to build intelligent agents that match compute and storage with location; what could we free up computers to do? what could we free up people to do?</li><li>One possible result is this could change the nature of a program.</li><li>There&rsquo;s interesting research emerging around these topics. Check out this <a href="https://youtu.be/0cfJNFt1bWA?t=4391">keynote address</a> by Peter Alvaro at this year&rsquo;s <a href=https://papoc-workshop.github.io/2021/>PAPOC conference</a>.</li></ul><p><strong>Related Resources</strong></p><ul><li><a href=https://www.eecs.harvard.edu/~cs161/notes/lfs.pdf>LFS explanation with amusing graphics</a></li><li>Ben Stopford&rsquo;s <a href=http://www.benstopford.com/2015/02/14/log-structured-merge-trees/>Log Structured Merge Trees</a></li><li><a href=https://aws.amazon.com/efs/when-to-choose-efs/>Amazon Elastic File Storage with comparison to Elastic Block Storage</a></li></ul><h2 id=session-9-computing-on-distributed-data>Session 9: Computing on Distributed Data</h2><p><strong>Date</strong>:
August 11 8:30PM EDT/August 12 8:30AM HKT</p><p><strong>Reading</strong>:</p><p>Zaharia, et al. (2012) <a href=https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf>Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</a></p><p><strong>Questions and Discussion Points:</strong></p><p>Distributed Computation vs Distributed Storage</p><ul><li>Although the Spark paper is not strictly related to intelligent distributed systems, the model that Spark uses to distribute computation across sections of a dataset is very reminiscent of the shared log abstraction from the distsys literature.</li></ul><p>Which Models Distribute?</p><ul><li>Models that are convenient to sparkify: when it&rsquo;s straightforward to express the algorithm in terms of a series of transformations<ul><li>Logistic regression & other GLMs</li><li>Tree-based models</li><li>kMeans clustering</li><li>topic modeling</li></ul></li><li>Models that don&rsquo;t work well with the spark model: when partitioning the data interferes with the model&rsquo;s ability to learn or generalize the decision space<ul><li>kNN</li><li>non-linear SVM</li><li>time series data models</li></ul></li></ul><p>Other Ways to Scale Computation</p><ul><li>For the Python/NumPy/Pandas/Sklearn Community<ul><li><a href=https://dask.org/>Dask</a>: advanced parallelism for analytics</li><li><a href=https://github.com/databricks/koalas>Koalas</a>: pandas API on Apache Spark</li><li><a href=https://spark.apache.org/mllib/>MLlib</a>: Apache Spark&rsquo;s scalable machine learning library</li></ul></li><li>For Time Series Analytics<ul><li><a href=http://btrdb.io/>btrdb</a>: rapid storage and analytics for scalar-valued timeseries data</li><li><a href=https://www.timescale.com/>Timescale DB</a>: PostgreSQL for time‑series</li></ul></li><li>More!<ul><li><a href=https://ray.io/>Ray</a>: Fast and Simple Distributed Computing</li><li><a href=https://julialang.org/>Julia</a>: a new programming language for high performance analytics</li></ul></li></ul><p><strong>Related Resources</strong></p><p>Bengfort & Kim (2016) <a href=https://learning.oreilly.com/library/view/data-analytics-with/9781491913734/>Data Analytics with Hadoop</a></p><h2 id=session-10-the-importance-of-understandability>Session 10: The Importance of Understandability</h2><p><strong>Date</strong>:
August 18 8:30PM EDT/August 19 8:30AM HKT</p><p><strong>Reading</strong>:</p><p>Ongaro & Ousterhout (2013) <a href=https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf>In Search of an Understandable Consensus Algorithm</a></p><p><strong>Questions and Discussion Points:</strong></p><p>Raft vs Paxos</p><ul><li>This paper is presented in a different way vs Lamport’s Paxos paper; it’s mostly about implementation; Paxos was more about theory (and even storytelling); this was about implementation with primitives like RPCs</li><li>There are similar concepts in the two papers like the logical clock, turns, etc</li><li>Raft &ldquo;feels&rdquo; of a different, newer era; Paxos assumes compute time is expensive so presents a theory based on those constraints vs. Raft which was written in a time when compute is much more abundant</li><li>Raft is a more understandable algorithm compared to Paxos; with Paxos, the algorithm is revealed piecemeal and is not so much presented as a system; Raft is presented as a complete system/implementation</li><li>The main thrust of Raft was about understandability; it offers similar performance as Paxos but is much simpler to reason about</li><li>As engineers, we work to marginally optimize performance whereas understandability is often undervalued and understated; Diego&rsquo;s (paper’s author) hook was understandability and he was surprised that it was so compelling</li><li>Another angle of the Raft paper is it&rsquo;s application and adaptability to situations in the real world</li><li>Raft also used creative ways to express functionality e.g. the &ldquo;heartbeat&rdquo; as the mechanism for the system to check the state of the leader; maybe this makes it more relatable</li><li>Also what makes it relatable is that two Stanford PhDs said out loud that &ldquo;Paxos is hard to understand&rdquo;, which was probably novel</li><li>However, not everyone thinks Raft is easier; it depends on your mental model; the lineage that produced Raft believed that Paxos was intentionally obfuscated because of how the paper was written vs another lineage who inherited from the Paxos tradition</li><li>For example <a href=https://arxiv.org/abs/2012.15762>Michael Whittaker&rsquo;s paper on &ldquo;compartmentalization&rdquo;</a> whereby the leader delegates/ communicates to a lower level set of proxy leaders to take pressure off the leader, might be seen as a Paxos &ldquo;revival&rdquo;</li><li>The Paxos paper included a formal proof whereas Raft was about an interesting/unexpected edge case and Raft was the simplest/best solution</li><li>It is interesting to perceive different cultures and lineages in the distributed systems domain</li></ul><p>Paxos vs Raft in Use</p><ul><li>Spanner: Paxos; this is a Google implementation of fast Paxos</li><li>Chubby: Paxos; a distributed lock server that was built to bail the GFS out of trouble</li><li>Zookeeper: is Paxos-like but technically ZAB not Paxos</li><li>Kubernetes: etcd, which uses Raft</li><li>MongoDB: Raft for replication</li><li>Yugabyte: Raft</li><li>CockroachDB: Raft</li><li>Interesting to apply the &ldquo;90/10&rdquo; rule to Paxos and Raft<ul><li>Paxos is hard implement for 90% of use cases, but once you get to 90%, the remaining 10% is &ldquo;easy&rdquo;</li><li>Raft covers 90% of use cases, but the &ldquo;dragons&rdquo; live in the 10%; those high throughput, edge cases, that&rsquo;s when things get difficult or impossible in Raft</li></ul></li><li>Because of its understandability, Raft became a class project in many comp sci grad classes; many grad students implemented Raft and, in doing so, found a lot of edge cases where Raft struggles or doesn&rsquo;t work</li><li>For example, many found that Raft can get into &ldquo;thrashing&rdquo; where there are multiple competing leaders who keep incrementing the term number and so candidates keep failing because they can&rsquo;t get enough votes, which makes Raft unavailable; basically, everyone fails and no one has availability</li><li>In contrast, Paxos is designed so it will never be unavailable</li><li>In Raft, time is not a &ldquo;lie&rdquo;; we can use an actual clock and call each other to figure things out</li><li>Raft uses actual clocks vs Paxos, which uses message time and the ordering of when messages are received, which is not really time; one is more intuitive whereas the other is more abstract</li><li>From an engineering perspective, these are two different philosophical approaches to the application of time to systems</li><li>One issue in Paxos is &ldquo;Eventual Availability&rdquo;; when a node becomes a leader, it&rsquo;s not guaranteed that they are up to date; there can be a slow period of updating if some of the machines are older or use outdated technology, which can&rsquo;t happen in Raft</li><li>Technically, Paxos and Raft are actually not that different; the algorithms are similar and both satisfy the two main conditions of (1) state machine safety (<em>if one server applies a log entry at a given index, no other server will apply a different log entry to that index)</em> and (2) leader completeness (<em>if an operation is committed at some index by the leader, all subsequent leaders will have that same operation at the same index</em>); yet they are in many ways defined by their &ldquo;origin stories&rdquo;</li></ul><p>Scalability of Raft & Paxos</p><ul><li>How much applied research has there been about the scalability of Raft and Paxos?</li><li>They are both single leader distributed log systems; it seems the leader will get overwhelmed with messages and communication as it scales</li><li>A paper called &ldquo;Raft Re-floated&rdquo; explored the scalability of Raft</li><li>It focuses on the importance of what happens at boot time in Raft; there&rsquo;s a balancing act; there is an interval/ heartbeat because if all nodes send votes at the same time, then they will land at the same time and will stall; whereas if the time interval is too long between heartbeats, then the wait time can take too long for modern systems and user expectations; so what you do at boot is important</li><li>Raft does not scale beyond 5-7 nodes; you&rsquo;ll quickly run into the &ldquo;thrashing&rdquo; problem</li><li>How is Raft so popular if it will thrash at 5-7 nodes? Two possible explanations for Raft&rsquo;s popularity: (1) In its design, the most performant node will &ldquo;win&rdquo; i.e. the node with more connectivity/ CPU/ Up Time will outperform the other nodes; (2) It&rsquo;s much more easier to implement compared to Paxos</li><li>The scalability of Paxos depends on how it&rsquo;s implemented e.g. compartmentalization is an approach where the leader delegates some communications to proxy leaders and the acceptors scale in a round-robin process</li><li>One analogy for scaling both algorithms is imagining building a row of legos and you want to place the same bricks with the same colors on top of each other quickly; we can go as fast we can, but that will most likely result in the row being out of order</li><li>All of these options are about how to slow down and get it right in the same order vs. speed</li><li>In reality, it&rsquo;s hard to compare Raft vs Paxos at scale, there&rsquo;s no easy way to benchmark them, which is why a consensus API may be useful!</li></ul><p><strong>Related Resources</strong></p><p>Whittaker (2020) <a href=https://www.bilibili.com/video/BV1wo4y1U7d2/>Scaling Replicated State Machines with Compartmentalization</a></p><p>Whittaker, et al. (2020) <a href=https://arxiv.org/abs/2012.15762>Scaling Replicated State Machines with Compartmentalization (Technical Report)</a></p><h2 id=farewell-and-onto-new-things>Farewell and Onto New Things&mldr;</h2><p><strong>Date</strong>:
August 25 8:30PM EDT/August 26 8:30AM HKT</p><p><strong>Reading</strong>:
No reading this week! We&rsquo;ll be talking about two open source opportunities&mldr;</p><p><strong>Open Source Projects:</strong></p><p><a href=https://github.com/rotationalio/honu>Honu</a></p><ul><li>Anti-entropy replication is common in systems but not generally used by application
developers; the goal of Honu is to make anti-entropy more accessible</li><li>We can build a library for embedded database replication and with eventual consistency we want to prove there is no additional overhead with replication</li><li>Benefits developers with geo-distributed system across the world with different latencies, different network conditions</li><li>Honu provides eventual consistency and allows for different types of bandits and different types of possibilities</li><li>This project has a <a href=https://github.com/rotationalio/honu>code base</a>, which is the bare minimum setup for anti-entropy</li><li>We have an embedded database that we want Honu to wrap; all it does now is wrap a
LevelDB database, though we could have an embedded Badger or Rocks or sqlite database</li><li>Embedded databases are often used for local development; Honu wraps that key-value store, gives you the benefits of speed, and gives you replication, which you can put on a server</li><li>Honu versions the data instead of overwriting it; it preserves the version history</li><li>It has 4 basic actions: get/put/delete/iter</li><li>The database is actually saving objects that are defined by default to have geo-replicated properties</li><li>It keeps info on parents so you can follow-back version history, it&rsquo;s not real time but sequenced</li><li>What&rsquo;s not implemented yet is replication; there&rsquo;s a sketch but there are different ways we can do this</li><li>There&rsquo;s also a nil variable so we can add options and features</li><li>We have some <a href=https://github.com/rotationalio/honu#readme>benchmark data</a> too; Honu is comparable to bare-metal LevelDB, which is both promising and means there&rsquo;s a lot of room for improvement</li><li>We want to investigate the consistency &ldquo;gotchas&rdquo;</li><li>There are opportunities to code, write, and experiment</li><li>We can move in several directions:<ul><li>Build it to wrap or bolt on replication to an existing database;</li><li>Make it general purpose i.e. “bring your own database”;</li><li>Focus only on LevelDB since it’s available in many different languages so we could implement Go/Python/C++ Honu</li></ul></li><li>We could also think about how to implement partial replication</li><li>You don’t need to be a skilled Go developer because the advanced features in Go are not used heavily in Honu; it&rsquo;s a single process, not using channels.</li></ul><p>More resources about anti-entropy & Honu</p><ul><li>Bengfort, et al. <a href="https://drive.google.com/file/d/1nNxaVjZUsF2RY1lsTj3i2z09FZzXrsZ1/view?usp=sharing">Anti-entropy Bandits (poster)</a></li><li><a href="https://youtu.be/9KX2wvAgVSo?t=1634">CSE138 (Distributed Systems) L14: Dynamo: Merkle trees, quorum consistency, tail latency</a></li><li><a href="https://youtu.be/JirCwLXlH_c?t=380">Anti-Entropy Using CRDTs on HA Datastores @Netflix</a></li><li><a href=https://youtu.be/TCiHqF_XTmE>Martin Sumner - Riak 3.0 and efficient anti-entropy - Code BEAM STO</a></li><li><a href="https://youtu.be/Y1WB6_drmus?t=1184">Apache Cassandra Lunch Online Meetup #16: Cassandra Anti-Entropy, Repair, and Synchronization</a></li></ul><p>Concur</p><ul><li>Organized around the idea that there is no one best consensus algorithm</li><li>We don&rsquo;t have a repo yet; it&rsquo;s just an idea!</li><li>The paper we read “Scalable but Wasteful” calls into question if consensus algorithms really help people in industry</li><li>It would be an API for consensus similar to the sci-kit learn API for ML</li><li>With sci-kit learn, they came up with a common interface for ML (fit + predict; fit + transform)</li><li>It was based on the premise that there&rsquo;s no such thing as a “best” ML model</li><li>There’s some interest in this project from academia.</li><li>This would be a big undertaking since we have no code base and we&rsquo;d have to explain the use cases and its application</li><li>Up for the challenge? Sign up <a href=https://tinyurl.com/concurapi>here</a></li></ul><p>More resources about Concur</p><ul><li>Buitinck et al. (2013) <a href=https://arxiv.org/abs/1309.0238>API design for machine learning software: experiences from the scikit-learn project</a></li><li>Bilbro (2021) <a href=https://postgresconf.org/conferences/2021_Postgres_Conference_Webinars/program/proposals/beyond-off-the-shelf-consensus>Beyond Off-the-Shelf Consensus.</a> PostgresConf.</li><li>Whittaker et al. <a href=https://mwhittaker.github.io/publications/quoracle.html>Quoracle</a></li><li>Kingsbury et al. <a href=https://github.com/jepsen-io/maelstrom>Maelstrom</a></li></ul><footer class=footline></footer></div></div><div id=navigation></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/js/clipboard.min.js?1632961070></script><script src=/js/perfect-scrollbar.min.js?1632961070></script><script src=/js/perfect-scrollbar.jquery.min.js?1632961070></script><script src=/js/jquery.sticky.js?1632961070></script><script src=/js/featherlight.min.js?1632961070></script><script src=/js/highlight.pack.js?1632961070></script><script>hljs.initHighlightingOnLoad()</script><script src=/js/modernizr.custom-3.6.0.js?1632961070></script><script src=/js/learn.js?1632961070></script><script src=/js/hugo-learn.js?1632961070></script><script src=/mermaid/mermaid.js?1632961070></script><script>mermaid.initialize({startOnLoad:!0})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PH909JD7LX"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PH909JD7LX')</script></body></html>